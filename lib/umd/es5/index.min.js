!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var o in n)("object"==typeof exports?exports:e)[o]=n[o]}}(window,function(){return function(e){var t={};function n(o){if(t[o])return t[o].exports;var r=t[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=e,n.c=t,n.d=function(e,t,o){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)n.d(o,r,function(t){return e[t]}.bind(null,r));return o},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([function(e,t,n){"use strict";n.r(t),n.d(t,"setCustomUrlResolver",function(){return a}),n.d(t,"addKnownModule",function(){return c}),n.d(t,"genModuleGlobal",function(){return p}),n.d(t,"default",function(){return m});const o=new Function("return Object.getPrototypeOf(async function(){}).constructor")(),r=e=>e.replace(/\brequire\s*[(]/g,"await require("),s=e=>/module[.]exports/.test(e);function i(e,t){return/^(https?[:])?[\/][\/]/i.test(e)?e:/^[a-z_$]/i.test(e)?`https://unpkg.com/${e}`:t?new URL(e,t).href:e}var u=i;function a(e){u=e||i}const d={};function c(e,t){d[u(e)]={isKnown:!0,isLoaded:!0,type:"isBuiltin",module:t}}async function l(e){return(await m(e)).module}c("load-dynamic-module",m),c("require-async",l),c("async-require",l);const f={};function p(e,t){f[e]=t}async function m(e,t=window.location.href){const n=u(e,t,i);return new Promise(async i=>{const u=d[n]||(d[n]={isKnown:!1,module:void 0});function a(t,o){if(1===arguments.length){const o=u.err=t,r=`dynamic module ${e} (${n})`;"SyntaxError"===o.name&&/await.+async.+function/i.test(o.message||"")?console.warn(`${r} may be CommonJS with nested requires\n\t(only top-level requires are supported by loadModule)`):console.error(`${r} failed to be loaded`,o)}else u.module=t,u.type=o;u.isLoaded=!!u.module,u.listeners.forEach(e=>e(u)),i(u)}if(u.isKnown)if(u.isLoaded||u.err)i(u);else{if(t){const n=u.dependents.find(e=>e===t);if(n)return a(new Error("CYCLYCAL DEPENDENCY: "+e+"<--\x3e"+n));u.dependents.push(t)}u.listeners.push(e=>i(e))}else{Object.assign(u,{isKnown:!0,dependents:[t],listeners:[],moduleRequestUrl:e,actualModuleUrl:n});try{const t=await function e(t,{method:n="GET",retry:o=3,retryDelayInMS:r=500}={}){return new Promise((s,i)=>{const u=new XMLHttpRequest;u.onreadystatechange=(()=>{if(4===u.readyState)if(u.status>=200&&u.status<300)s({data:u.responseText,responseURL:u.responseURL});else if(u.status>=500&&o-- >0)setTimeout(()=>{e(t,{method:n,retry:o,retryDelayInMS:r}).then(s).catch(i)},r),r*=2;else{const e=new Error(`failed to ${n} ${t} [${o<=0?"too many retries;":""}http-code=${u.status}${u.statusText?`(${u.statusText})`:""}]`);e.name=`HTTP-${n}-Error`,e.statusCode=u.status,e.statusText=u.statusText,i(e)}}),u.open(n||"GET",t,!0),u.send()})}(n),i=t.responseURL,u=t.data,d={define:l,module:void 0,require:()=>{throw new Error("require is invalid in AMD modules (use require-async instead): "+e)}},p={define:()=>{throw new Error("unexpected use of DEFINE in commonJS module")},module:{exports:{}},require:async e=>(await m(e,i)).module},y={names:[],values:[]};Object.entries(f).forEach(([e,t])=>{y.names.push(e),y.values.push(t(d,p))});const w=new o("define","module","exports","require",...y.names,u);l.amd={};var c=!1;function l(...e){c=!0;const t=e.pop();if("function"!=typeof t)throw new Error(`expecting 'define' to be a function (was ${typeof t})`);const n=t.length,o=[];for(;o.length<n;){const t=e.pop();if("string"==typeof t)o.unshift(t);else{if(!Array.isArray(t))throw new Error("invalid dependency in AMD module definition - can only be a string or an array of strings");for(;o.length<n&&t.length>0;){const e=t.pop();if("string"!=typeof e)throw new Error(`invalid dependency in AMD module definition - can only be a string (got type=${typeof e})`);o.unshift(e)}}}const r=o.map(e=>m(e,i));Promise.all(r).then(e=>{try{a(t(...e.map(e=>e.module)),"AMD")}catch(e){a(e)}})}try{await w(d.define,d.module,(d.module||{}).exports,d.require,...y.values)}catch(e){c&&a(e)}if(!c)if(s(u)){const e=r(u),t=new o("module","exports","require",...y.names,e);try{await t(p.module,(p.module||{}).exports,p.require,...y.values),a((p.module||{}).exports,"CommonJS")}catch(e){a(e)}}else a(new Error("module seems to be neither AMD/UMD nor CommonJS"))}catch(e){a(e)}}})}}])});