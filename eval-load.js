/* do NOT "use strict"; because that invalidates using 'with' statement below */
/* do NOT use 'import' or 'export' because that will implicitly triggers strict mode */
/* hence, we use the module.exports below form (which does not trigger strict mode) */

// ON LOADING modules from server: if package.json has BROWSER field:
// - if string, download that
// - if object AND requested file has redirect, use that
// - BUT, how to know that a file is being redirected???
//      - for each request below node_modules,
//          - need to read package.json first and see if redirected?


// git commit -am ".."


// can verify regular expressions here: https://www.regexpal.com/ and https://regex101.com/ 
const toRegEx = (srcRE,bs,flags) => new RegExp(srcRE.replace(/[#].*/g, '').replace(/\s+/g,'').replace(bs, '\\'), flags);

const commentsPat = toRegEx(`
    ## must look for (and ignore) quoted strings because could contain text that looks like comments

    ## quoted strings
    (['"\`])                    ## start (opening quote); becomes ~1
    (~~~1|(?:(?!~1)[~s~S]))*?   ## quoted content (sans quotes); ~~~1 allows for embedded quotes
    ~1                          ## end (same as opening quote)
  |
    ## comments
      [/][/].*              ## end-of-line
    |
      [/][*][~s~S]*?[*][/]  ## multiline
`, /[~]/g, 'g');

function removeComments(code) {
    //const comments = /(['"`])(\\\1|(?:(?!\1)[\s\S]))*?\1|[/][/].*|[/][*][\s\S]*?[*][/]/g;
    return code.replace(commentsPat, full => (full[0] === '/') ? (full[1] === '/' ? '' : /\n/.test(full) ? '\n' : ' ') : full);
}

// function removeQuotesAndComments(code) {
//     const comments = /(['"`])(\\\1|(?:(?!\1)[\s\S]))*?\1|[/][/].*|[/][*][\s\S]*?[*][/]/g;
//     return code.replace(comments, full => (full[0] === '/') ? (full[1] === '/' ? '' : /\n/.test(full) ? '\n' : ' ') : full);
// }

function genExtractRequiresPat(requireName) {
    return toRegEx(`## using '~' as backslash character (easier than to have to double them up: \\)

        (?:
            ## ignore quoted strings because may include require-like text
            (['"\`]) ## string start (will become \\2)
            (~~~2|(?:(?!~2)[~s~S]))*? ## actual string content: allows for escaped quote
            ~2 ## string end
        )   
      |
        (?:
            ## ignore 'embedded_requires' or used as someones.require property
            [.$_]~s*${requireName}
        )
      |
        ~b
        (   ## the FULL_REQUIRE part we want
            ${requireName}~s*[(]     ## 'require(' including opening paren
            (
                ## simple-string require
                ~s*
                (['"\`])      ## opening quote: 3rd paren in (skipping over non-captured groups)
                (((?!~3).)+?) ## REQUIRE_DEP content: we ignore escaped/embedded quotes: too much an edge case for this
                ~3~s*[)]      ## closing quote and trailing closing paren
              |
                ## non-simple-string require (either an expression or multiple parms)
                [^)]+?[)]  
            )
        ) 
    `, /[~]/g, 'g')
}

/*
    // AMD: https://requirejs.org/docs/api.html


    // according to: https://requirejs.org/docs/commonjs.html
    // define(function(...){}) must ALWAYS be:
    // - either 'require'
    // - or 'require,exports,module' IN THAT ORDER and with those EXACT NAMES

    // We only implement a small subset of AMD, as likely generated by webpack and rollup
    // Manual AMD modules may not work with load module
    // - if need manual, use our x-define
    // - if need to use someone else's manual AMD, sorry...

    // what we implement:
    // - require, module, exports as deps
    // - no-deps + function()
    // - no-deps + function(require)
    //      - mods are pre-extracted: dep names are simple strings
    // - no-deps + function(require,exports,module) (in any order)
    // - require & requirejs: ([deps], execFcn())

    // prefix in names: text! css! html!

    // NO config
    // no jsonp

    // AMD reqs:
    // - url is ID unless ends with .js, or starts with /, or a url protocol (http://)
    //   then uses baseUrl/urlAsID
    // - require or requirejs (apparently)
    // from https://requirejs.org/docs/api.html#define 
    // - define({can be object}) defines an object module (also string or array or other non-function? why not)
    // - define(function definitionFcn(){}) no deps and function.length === 0; returned from definitionFcn is module
    // - define(function(require, exports, module) {}); - no deps 1, 2, or 3 parms
    //      - whoaaa
    // - require CAN be asked as a dependency: if dep is 'require' will return require code as a dependency: so, a reserved dep name
    // - require.toUrl function is NOT implemented

    // 'exports' is special dependency case; can then be used as expotrs.x inside defFcn

    // start something is: requirejs([deps], starter(){});

    // loadModule.config() returns a loading function

    // we do NOT honor requirejs.config({...})

            // AMD using the the require format: need to extract required deps
*/

function extractRequireDependencies(fcn, makeAwaitable = false) {

    // call this method when you know there are going to be 'require('x');' inside the function

    // AMD using the the require format: need to extract required deps

    const fcnCode = removeComments(fcn.toString()); // important, else comments can obscure 'require' pattern matching
    const //functionParmsPat = /^\s*function\s*[(]\s*([^)]+)[)]/,
          //reqname = fcnCode.match(functionParmsPat)[1], // extracts parm names
          requireDepPat = genExtractRequiresPat('require');//reqname);

    const dependencies = [];
    const finalCode = fcnCode.replace(requireDepPat, (full, fullRequire, requireParms, requireQuote, requireDep) => {
        if (requireDep) {
            dependencies.push(requireDep.trim());
            return fullRequire;
        }
        else {
            // construct below (prepend 'await') will FAIL if anything follows require [such as require(...).field 
            // or require(...)(...immediate function call)] because right-associativity precedence rule means
            // that the full expression will be awaited (wrong for us) rather than just the require part
            return (makeAwaitable ? 'await ':'') + fullRequire; // so must use with care (i.e. only in simplest of cases)
        }
    });

    return [dependencies, finalCode, require, exports, module];
}

// RULE: in order to import CJS modules, some code transpiling is required. In some edge cases, the transpiling may fail.
// for those cases, changing the edge case(s) if best else use an AMD version of that module (used as-is, no transpilation)
// edge cases:
//  - a regex which contains // or /* (both likely errors)
//  - comment(s) between 'require' and the opening paren '(' or within the parentheses (i.e. before the closing paren)
//  - embedded tick-quoted-text inside another tick-quoted-text: e.g. const x = `this is some ${choice? `1` : `2`} text`;
//      - although, if no require in between, might work since tick marks should be balanced (right?)

function xxextractDependencies(srcCode) {

    // can verify this here: https://www.regexpal.com/ and https://regex101.com/ 

    // quotes required in both so as to not process quoted text that looks like a comment or require
    const comments = /(['"`])(\\\1|(?:(?!\1)[\s\S]))*?\1|[/][/].*|[/][*][\s\S]*?[*][/]/g;
    const requires = /((['"`])(\\\2|(?:(?!\2)[\s\S]))*?\2)|([.$_]\s*require)|\b(require\s*[(](\s*(['"`])(((?!\7).)+?)\7\s*[)]|[^)]+?[)]))/g;

    const dependencies = [];
    const modifiedCode = srcCode
        .replace(comments, full => { // do comments first so have clean whitespace to work with on requires
            return (full.length > 1 && full[0] === '/') ? (full[1] === '/' ? '' : full.indexOf('\n') === -1 ? ' ' : '\n') : full;
        })
        .replace(requires, (full, quotedText, quoteChar, unquotedText, notRequired, fullRequire, requireParm, requireQuote, requireDep) => {
            if (quotedText || notRequired) return full;
            if (requireDep) {
                dependencies.push(requireDep.trim());
                return fullRequire;
            }
            else {
                // construct below (prepend 'await') will FAIL if anything follows require (e.g require(...).field 
                // or require(...)(...immediate function call)) because the await applies to full expression
                // not just the require part (precedence)
                return 'await ' + fullRequire; 
            }
        });

    return [dependencies, modifiedCode]
}

/* More involved Strategy 2 (unused for now)
    // find out how many deps the moduleDefine function expects
    // WHOAAA: BUT if function uses ...ARGS format (i.e. the spread/rest operator), FUNCTION.LENGTH === 0!!!
    const numDeps = moduleDefine.length; // ...function.length returns how many parms (so, deps) are declared for it

    // WHOAAA, part 2: if numDeps === 0, may mean NO parms, or means ...parms: how to proceed???
    // if (numDeps === 0 && args.length > 0)
    //     throw new ModuleLoadError(`define method takes no parms but some dependencies declared\n\t[possible issue: 'define(...parms){}' declaration format NOT supported]`); // give users a hint

    // we allow for either an array of deps (traditional) or just comma-separated parms (for convenience when creating amd modules manually)
    // we're also ok with a mixture of strings and arrays (of strings only), though not clear why that would be the case
    // and we always work backwards on parms (from right to left) to allow for possibility of a module name at the front/leftmost position
    // (as per traditional, in case first/leftmost parm is module's 'name', as is typical of AMD define([mod-name,][...deps,] fcn(...depRefs){}))
    // IF a module name is specified, it remains UNUSED (not needed for modules loaded by URLs)
    // POSSIBLE: if single string parm left (i.e. module name), maybe register it as the module's name also: i.e. as an alias
    // - but what happens if another module wants that name: overwrite? remove both? keep first? keep both?
    // alternative: Array.flat() would be REALLY NICE here, but Edge does NOT support it (as of feb 6, 2019)
    // - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat
    const externals = [];
    while(externals.length < numDeps) {
        const nextDep = args.pop(); // from right/back to left/front 
        if (typeof nextDep === 'string')
            externals.unshift(nextDep); // add to front/left of array
        else if (Array.isArray(nextDep)) {
            while (externals.length < numDeps && nextDep.length > 0) { // process nested deps
                const nd = nextDep.pop(); // take last one (so going from back to front)...
                if (typeof nd === 'string')
                    externals.unshift(nd); // add to front of array
                else 
                    throw new ModuleLoadError(`invalid dependency in AMD module definition - can only be a string (got type=${typeof nd})`);
            }
        }
        else 
            throw new ModuleLoadError(`invalid dependency in AMD module definition - can only be a string or an array of strings`);
    }
*/

// BELOW (commented out): this is the module's name (as module author wants it defined, if strictly following AMD define) 
// - [we're not using it here: code is for reference only]
// if (args.length === 1 && typeof args[0] === 'string') { ...UNUSED for now...
//     // maybe set option to use only URLs, URLs AND named defines, or just named defines (if no name, use url)
//     // to consider: add option in case of conflicts: replace with newer/last-loaded, remove both, keep first (e.g. different url but same name)
// }


function genAMDDefine(thisModule, subDepResolution) {

    //const thisModule = this; // self ref for within amdDefine below

    // IMPORTANT: all AMD modules test for 'define.amd' being 'truthy'
    //            but some (e.g. lodash) ALSO check that "typeof define.amd == 'object'" so...
    defineMethod.amd = {}; // ...use an object (truthy) NOT just 'true'

    // keep track of whether or not our define method was actually called...
    var isAMD = false; // ...because if not called, likely NOT an AMD module
    function defineMethod(...args) {

        // this is what is actually executed when src code calls define(...)

        // at this point we know we're in an AMD module since this define method was called from module source code
        // so if any errors after this (e.g. coding errors), we won't bother with trying CJS

        isAMD = true; // yay!

        // now, parse parms as an actual AMD module...

        const moduleDefine = args.pop(); // always last param
        if (typeof moduleDefine !== 'function') 
            throw new ModuleLoadError(`expecting module definition to be a function (was ${typeof moduleDefine})`);
        //

        const externals = [];

        // now get/extract dependencies

        if (args.length > 0) {

            // explicit dependencies
            // check for dependencies, then execute define [our current code]
            // SIMPLE STRATEGY 1: implement as AMD expects (a single array of dependencies)
            
            const depsArray = args.pop() || []; // expect an array or nothing
            if (Array.isArray(depsArray))
                externals.push(...depsArray);
            else
                throw new ModuleLoadError(`expecting '[dependencies]' to be an array (was ${typeof externals})`);

            // BUT, if one of these is 'require' THEN need to extract anyway
        }

        // const usesRequire = external.find(dep => /^require$/.test(dep));

        // if (usesRequire) {
        //     // will be resolved as part of dep resolution process (each is an independent awaitable task)
        // }

        if (externals.length === 0) {
            // NO explicit dependencies passed
            if (moduleDefine.length === 0) {
                    // regular module, no deps: just execute define
                    // fall through

                // BUT, if externals contains 'require', that's probably a mistake
                // on executing, should still have access to require (as parm? as proxied-global?)
            }
            else if (moduleDefine.length >= 1) { // should be 1, 2 or 3

                const [deps, fcnsrc, require, exports, module] = extractRequireDependencies(moduleDefine);

                if (require) {
                    // need to add require (maybe exports/module) available to name space
                    // just pre-pend them to deps array: will 
                    // push to front of array (also exports and module)
                }
                else {
                    // expecting require/exports/module
                    // not sure what we got...
                }        
            }
            else {
                // unexpected: warning define seems to expect dep parms, but none (or not proper) specified: executing anyway... 
                // maybe passed parms expecting them to be 'undefined'?
                //log.warning('unexpected define usage: seems to expect dep parms, but none specified - executing anyway')
                // fall through
            }
        }
        else {
            // if (externals.length !== moduleDefine.length) 
            //     ; // all good
            // resolve deps as expected
                    // mismatch: deps but definitionFcn not expecting any
                    // - that could be ok if not expecting modules to return anything, where
                    //   each module may only be used for its side-effect
        }

        const resolvedDeps = externals.map(dep => {
            if (dep === 'require'){}
            else if (dep === 'exports') {}
            else if (dep === 'module') {}
            else return thisModule.log(dep);
        });

        Promise.all(resolvedDeps).then(deps => {

        })
    
        // resolve dependencies
        privateLoader(subDepResolution, ...externals)
            .then(async depOrDeps => {
                const resolvedDeps = Array.isArray(depOrDeps) ? depOrDeps : [depOrDeps]; // todo: change this if ALWAYS returning an array
                const errs = resolvedDeps.filter(dep => dep instanceof Error);
                if (errs.length > 0) {
                    // resolved dependencies ERRORS will PREVENT AMD Define method from executing
                    // - that's a big difference between AMD modules and ours
                    thisModule.resolved(new ModuleLoadError(`AMD Define method NOT executed because of failed dependencies`, ...errs));
                }
                else {
                    try {
                        const result = await moduleDefine(...resolvedDeps);
                        if (typeof result === 'undefined') {
                            if (explicitlySet) // module.exports = ...
                                thisModule.resolved(module.exports); // but only if was assigned;
                            else if (Object.keys(exports).length > 0) // exports.[name] = ...
                                thisModule.resolved(exports); 
                            else 
                                thisModule.resolved();
                        }
                        else {
                            thisModule.resolved(result);
                        }
                        
                    }
                    catch(err) {
                        thisModule.resolved(new ModuleLoadError(`AMD Define method failed`, err));
                    }
                }
            })
    }

    var explicitlySet = false,
        explicitExports = {};
    const module = { 
              get exports() { return explicitExports; },
              set exports(v) { explicitExports = v; explicitlySet = true; return true; }
          };

    return { defineMethod, get isAMD() { return isAMD; }, };
}

// do both amd & cjs at once
// pre-define module, module.exports, require, define


// this is NOT secure
// - will still eval in GLOBAL context
// - we do have access to a general proxy which can easily be circumvented

// CANNOT use ES6 export to export this module because this would INVALIDATE our use of the 'with'
// statement insode executeCode; we MUST use 'module.exports' construct
module.exports = { executeCode, extractRequireDependencies};

/*
    AMD: 
        - we are AMD-like to work with webpack/rollup and npm
        - but we don' follow ALL its possibilities
            - e.g. 
            define('name', [...deps...], fcn onDepsReady(...deps...){})
                // defines a module (name becomes a private name for re-inclusion in deps)

        - if define(fcn) only
            - no deps, no name
            - and fcn has single parm
            - parm is 'require'
                - need to scan for it and extract 'string-only' deps

        require([...deps...], fcn onDepsReady(...deps...){}))
            // runs a module
            // if last parm is NOT function, it's a CJS require
                - allow anyway? --NO--
                    - would require pre-processing
                        - do a pre-download
                        - or convert to await
                            - top-level await is ok
                            - nested await will fail
                    - --BECAUSE-- if allow, custom code by/for us (no longer AMD)
                        - so maybe just change name? loadModule()?
                        - and if not a string use await?
                        - or always use await to keep simple
                        - allow multiple-at-once: 
                            const [mod1,mod2,mod3] = loadModule('mod1', 'mod2','mod3');

    CJS:
        require('name')
        require('ex' + 'pression).something
        require('dynamic' + 'ex' + 'pression)(execute-code)


*/

//export [see note above]
async function executeCode(srcCode, extraEnv = {}, mainGlobalWindow = window) {

    // for this code to work, CANNOT HAVE ANY 'import' statements in file
    // else it will trigger strict-mode: strict mode prevents using 'with' below
    // by generating a SyntaxError

    const usc = {}; // our Underlying Store/Cache, proxied as virtualPrivateEnv below
    const windowEnv = mainGlobalWindow; // give it a distinct name for code below
    const {$addNewVarsTo} = extraEnv,
          addNewVars = varname => typeof $addNewVarsTo === 'function' ? $addNewVarsTo(propname) : ($addNewVarsTo || 'private');

    // the template we use to wrap our srcCode
    // important: we MUST NOT "use strict"; else will prevent/break 'with' construct below
    // virtualPrivateEnv (at the very end) is our locally declared proxy (below) and is going to be the only 
    // non-proxied reference to outside world
    const evalCode = `(async function(window){
        with(window) {
            ${srcCode}
        }
    })`;//)(virtualPrivateEnv)`; 


    // will become the only "global" reference when eval used below
    // because will ALWAYS return true for ALL names (in .has() method)
    const virtualPrivateEnv = new Proxy(usc, {
        has(target, name) { return true; }, // always true: allows TRAPPING all names in srcCode
        get(target, propName, receiver) {
            if (propName === Symbol.unscopables) return {}; // important when using WITH
            if (/^window$/.test(propName)) return virtualPrivateEnv; // redirect back to us

            if (propName in extraEnv) return Reflect.get(extraEnv, propName);
            if (propName in windowEnv) return Reflect.get(windowEnv, propName);

            throw new ReferenceError(`${propName} variable not defined`);
        },
        set(target, propName, value, receiver) {

            // CAN 'return false;' to signal that assignement failed 
            // BUT, in NON-STRICT mode (which this must be for us to be able to use 'with'),
            // failed assignments are SILENTLY IGNORED by browsers (as per standard implementations)
            // and so cannot be trapped by user...

            if (propName in extraEnv) return Reflect.set(extraEnv, propName, value);
            if (propName in windowEnv) return Reflect.set(windowEnv, propName, value);

            // new variable: can add to extras, add to windows, or just fail
            // but for fail, we'd never know if it's var-declared or not (which could mean a typo)
            // AND, we've already said that this var exists (in .has() above) so...
            const addTo = addNewVars(propName);
            if (/^window$/i.test(addTo))
                windowEnv[propName] = value;
            else if (/^private$/i.test(addTo))
                extraEnv[propName] = value;
            else {
                // assignment is ignored
            }

            return true;
        },
        apply(target, propName, receiver) {
            // is this ever called?
            log('trying to apply something', propName);
        },
    });

    // this is NOT secure
    // - will still eval in GLOBAL context
    // - we do have access to a general proxy which can easily be circumvented
    const zz = eval(evalCode);
    return await zz(virtualPrivateEnv); // a PROMISE
}

// executeCode(someTestSourceCode, ourExtras)
//     .then(result => {
//         log('SUCCESS from our code', result);
//     })
//     .catch(err => {
//         log('FAILED/ERROR from our code', err);    
//     })

